# pipeline
--
    import "."

Package pipeline manages the lifetime of inputs and outputs.

## Usage

#### type Controller

```go
type Controller struct {
}
```

Controller manages inputs and outputs by creating a pipeline per output and
associating inputs with the pipelines. The Settings struct is used to set the
controllers should state. The UpdateConfig method can be used to update said
state. Once updated, the controller tries to modify its pipelines, inputs, and
outputs in order to converge to the new state.

#### func  NewController

```go
func NewController(
	log *logp.Logger,
	info beat.Info,
	inputsRegistry v2.Registry,
	outputFactory publishing.OutputFactory,
	settings Settings,
) (*Controller, error)
```
NewController creates a new controller. The logger and input registry MUST NOT
be nil. The controller is not active yet. The Run method must be used to
activate the controller.

#### func (*Controller) Run

```go
func (pm *Controller) Run(ctx context.Context) error
```
Run executes the controllers run loop. The run loop creates the internal
pipelines for Inputs and Outputs, and waits for configuration updates via
UpdateConfig.

All internal pipelines, inputs, and outputs are guaranteed to be stopped when
Run returns. The shutdown blocks until all internal go-routines are stopped.

The Controller struct stores no execution state, besides the execution settings
that can be modified asynchonously via UpdateConfig. It is safe to call Run
again in case it returned with (or without) an error. It is not safe to call Run
concurrently from multiple go-routines.

#### func (*Controller) UpdateConfig

```go
func (pm *Controller) UpdateConfig(settings Settings) error
```
UpdateConfig updates the controllers settings. If the controller is already
running, it will try to adapt itself to the latest settings dynamically.

UpdateConfig returns an error if it finds that the configuration can not be
applied. This normally indicates a parsing/validation error only. Even if nil is
returned, there is no guarantee that the input/output can actually be executed.

UpdateConfig does not block. Instead old updates that have not been processed
yet by the controller are dropped. This ensures that the controller can always
react to the most recent available configuration, even in cases with a burst of
sudden configuration updates.

#### type InputSettings

```go
type InputSettings struct {
	// Input ID generated by Integrations (optional)
	ID string `config:"id"`

	// User readable input name (optional)
	Name string `config:"name"`

	// Input type (XXX: depends)
	Type string `config:"type"`

	// Meta provides additional metadata that will be associated with the input
	// and all its streams.
	Meta map[string]interface{} `config:"meta"`

	// Namespace for the input and all configured streams.
	Namespace string `config:"data_stream.namespace"`

	// UseOutput configures the output the input shall be associated with.
	UseOutput string `config:"use_output"`

	// DefaultSettings provides a set of settings that will be shared by all streams.
	DefaultSettings *common.Config `config:"default"`

	// Streams configure the actual data collection. Internally each stream will create
	// a v2.Input instance.
	Streams []*common.Config `config:"streams"`
}
```

InputSettings provides the input configuration with all its data streams that
will be configured.

#### type Settings

```go
type Settings struct {
	Inputs  []InputSettings           `config:"club.inputs"`
	Outputs map[string]*common.Config `config:"outputs"`
}
```

Settings describes the configuration of inputs and output to be run.

#### func (*Settings) Validate

```go
func (s *Settings) Validate() error
```
Validate checks if the configuration can be applied. Input and output
configuration are not validated.

- a default output must be configured - the output mentioned in use_output must
exist
