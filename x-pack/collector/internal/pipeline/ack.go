package pipeline

import (
	"context"
	"sync"

	"github.com/elastic/beats/v7/libbeat/beat"
	"github.com/elastic/beats/v7/libbeat/common/atomic"
	"github.com/elastic/beats/v7/x-pack/collector/internal/cell"
	"github.com/elastic/beats/v7/x-pack/collector/internal/publishing"
)

// inputACKDecoupler implements beat.ACKer.
//
// ACK handling in inputs can lead to backpressure, staling updates at worst
// even in the output, which can result in overall backpressure thrughout the
// system. The inputACKDecoupler accumulates all historical state updates into
// acc, which is eventually handled by the actual ACKer. In case the inputs
// ACKer blocks, all updates are acculumates internally, allowing the outputs to progress without
// additional backpressure from the inputs.
type inputACKDecoupler struct {
	acker beat.ACKer

	// receiver state
	status *cell.Cell

	// sender state
	acc ackStatus
}

type ackStatus struct {
	done   bool
	closed bool
	acked  uint64
}

// The outputACKer implements the publishing.ACKCallback interface.
//
// It is used to eventually ignore event status updates from ACKs generated by outputs
// during the outputs shutdown or replacement process.
type outputACKer struct {
	closed atomic.Bool
	id     uint64
	events *eventTracker
}

// eventTracker keeps track of all active inputs and their event publishing status.
type eventTracker struct {
	// contexts stores the status of events. Each client has it's own status. This guarantees that we can
	// correctly ACK events to the original publisher.
	// The freelist tracks event contexts currently not in use. Old contexts get
	// reuse when a new client is connected (ensure IDs are stable and lookup is O(1)
	// Modifications to contextsMu and freelist must be protected using contextsMu.
	contextsMu sync.Mutex
	contexts   []*eventContext
	freelist   []uint32
	active     map[uint32]struct{}

	activeOutputID uint64
}

// eventContext keeps track of event publishing status of a single beat.Client instance, and
// ensures that ACKs are correctly returned, in publishing order, to the inputs ack handler.
type eventContext struct {
	publishMode beat.PublishMode

	ref uint32

	// outputID ensures that ACKs from old outputs can not modify the context
	// state.
	outputID uint64

	contextID uint32

	acker *inputACKDecoupler

	statusMu sync.Mutex
	startID  uint32

	// TODO: track event memory usage, so we account for overal memory usage for
	// events in progress and events published
	status []publishing.EventStatus
	events []beat.Event
}

type pendingEvent struct {
	id    publishing.EventID
	mode  beat.PublishMode
	event beat.Event
}

func newInputACKDecoupler(acker beat.ACKer) *inputACKDecoupler {
	dc := &inputACKDecoupler{status: cell.NewCell(ackStatus{})}
	go dc.run(acker)
	return dc
}

func (dc inputACKDecoupler) run(acker beat.ACKer) {
	var acked uint64
	var closed bool

	for {
		ifc, err := dc.status.Wait(context.Background())
		if err != nil {
			return
		}

		st := ifc.(ackStatus)
		n := st.acked - acked
		acked = st.acked
		if n > 0 {
			acker.ACKEvents(int(n))
		}

		if st.closed && !closed {
			closed = true
			acker.Close()
		}

		if st.done {
			return
		}
	}
}

func (dc *inputACKDecoupler) ACKEvents(n int) { dc.acc.acked += uint64(n); dc.forwardStatus() }
func (dc *inputACKDecoupler) Close()          { dc.acc.closed = true; dc.forwardStatus() }
func (dc *inputACKDecoupler) Release()        { dc.acc.done = true; dc.forwardStatus() }
func (dc *inputACKDecoupler) forwardStatus()  { dc.status.Set(dc.acc) }
func (dc *inputACKDecoupler) AddEvent(event beat.Event, published bool) {
	dc.acker.AddEvent(event, published)
}

func (o *outputACKer) UpdateEventStatus(id publishing.EventID, status publishing.EventStatus) {
	if o.closed.Load() {
		o.events.UpdateEventStatus(o.id, id, status)
	}
}

func (t *eventTracker) Register(publishMode beat.PublishMode, acker beat.ACKer) *eventContext {
	t.contextsMu.Lock()
	defer t.contextsMu.Unlock()

	var idx uint32
	if L := len(t.freelist); L > 0 {
		idx = uint32(L - 1)
		t.freelist = t.freelist[:L-1]
	} else {
		idx = uint32(len(t.contexts))
		t.contexts = append(t.contexts, nil)
	}

	var inputACKer *inputACKDecoupler
	if acker != nil {
		inputACKer = newInputACKDecoupler(acker)
	}

	ectx := &eventContext{
		publishMode: publishMode,
		ref:         1,
		contextID:   idx,
		acker:       inputACKer,
	}
	t.contexts[idx] = ectx

	if t.active == nil {
		t.active = map[uint32]struct{}{}
	}
	t.active[idx] = struct{}{}

	return ectx
}

func (t *eventTracker) Unregister(ctx *eventContext) {
	ctx.statusMu.Lock()
	ctx.ref--
	release := ctx.ref == 0
	ctx.statusMu.Unlock()

	if release {
		t.release(ctx)
	}
}

func (t *eventTracker) release(ctx *eventContext) {
	if ctx.acker != nil {
		ctx.acker.Release()
	}

	t.contextsMu.Lock()
	defer t.contextsMu.Unlock()

	idx := ctx.contextID
	t.contexts[idx] = nil
	delete(t.active, idx)

	// TODO: try to free more space
	if L := len(t.contexts); L-1 == int(idx) {
		t.contexts = t.contexts[:L-1]
	} else {
		t.freelist = append(t.freelist, idx)
	}
}

func (t *eventTracker) UpdateEventStatus(outputID uint64, id publishing.EventID, status publishing.EventStatus) {
	idx := id >> 32
	t.contextsMu.Lock()
	if t.activeOutputID != outputID {
		t.contextsMu.Unlock()
		return
	}
	ec := t.contexts[idx]
	t.contextsMu.Unlock()

	more := ec.updateStatus(outputID, id, status)
	if !more {
		t.release(ec)
	}
}

func (c *eventTracker) Lock() {
	c.contextsMu.Lock()
	for idx := range c.active {
		c.contexts[idx].statusMu.Lock()
	}
}

func (c *eventTracker) Unlock() {
	for idx := range c.active {
		c.contexts[idx].statusMu.Unlock()
	}
	c.contextsMu.Unlock()
}

func (c *eventTracker) SetOutputID(outputID uint64) {
	c.Lock()
	defer c.Unlock()
	c.activeOutputID = outputID
	for idx := range c.active {
		c.contexts[idx].outputID = outputID
	}
}

// SnapshotPending collects all pending events.
//
// NOTE: The call to SnapshotPending must be protected by the Lock() and
// Unlock() methods. The method does not acquire any locks!
func (c *eventTracker) SnapshotPending() []pendingEvent {
	var events []pendingEvent
	for idx := range c.active {
		ctx := c.contexts[idx]

		for i, status := range ctx.status {
			if status != publishing.EventPending {
				continue
			}

			events = append(events, pendingEvent{
				id:    publishing.EventID(ctx.startID + uint32(i)),
				mode:  ctx.publishMode,
				event: ctx.events[i],
			})
		}
	}
	return events
}

func (c *eventContext) RecordEvent(event beat.Event) publishing.EventID {
	c.statusMu.Lock()
	defer c.statusMu.Unlock()

	idx := len(c.status)
	c.status = append(c.status, publishing.EventPending)
	c.events = append(c.events, event)
	c.ref++

	id := publishing.EventID(uint64(c.contextID)<<32 | uint64(c.startID+uint32(idx)))
	return id
}

func (c *eventContext) updateStatus(outputID uint64, id publishing.EventID, status publishing.EventStatus) bool {
	refs, acked := func() (uint32, uint32) {
		c.statusMu.Lock()
		defer c.statusMu.Unlock()

		if outputID != c.outputID {
			return c.ref, 0
		}

		idx := uint32(id) - c.startID
		c.status[idx] = status

		var n uint32
		for _, st := range c.status {
			if st == publishing.EventPending {
				break
			}
			n++
		}

		c.startID += n
		c.status = c.status[n:]
		c.events = c.events[n:]
		c.ref -= n
		return c.ref, n
	}()

	if acked > 0 && c.acker != nil {
		c.acker.ACKEvents(int(acked))
	}

	return refs > 0
}
